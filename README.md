# Data Generator
A flexible Python tool for generating realistic synthetic data with complex dependencies between fields.

### Table of Contents

## Table of Contents
- [Installation](#installation)
- [API Endpoints](#api-endpoints)
- [Schema Structure](#schema-structure)
- [Field Types](#field-types)
- [Dependencies](#dependencies)


## Installation

### Using Docker Compose

**Prerequisites:** Ensure Docker is installed on your system. Windows users must also have WSL2 installed for Docker compatibility.
```bash
# Clone the repository
git clone https://github.com/ewanf2/Data_generator.git
cd Data-generator

# Build and start the service
docker-compose up -d --build

# View logs (optional)
docker-compose logs -f

# Stop the service
docker-compose down

# Stop the service and remove volumes
docker-compose down -v
```
Once running, Waitress will serve the Flask application. The API will be accessible at http://localhost:5050.

## API Endpoints

The  data generator provides a RESTful API for managing schemas and generating data using these schemas.

---

### View Supported Data Types

Get a list of all available data types that can be used in schemas.



**Endpoint:** `GET /datatypes`

**Example:**
```
curl http://localhost:5050/datatypes
``` 
This will display all the datatypes able to be generated by the application. 
### View all saved schemas
**Endpoint:** `GET /schemas`
**Example:**
```
curl http://localhost:5050/schemas
``` 
This endpoint will return a list of all schemas currently saved to the application. 

### View a specific schema
**Endpoint:** `GET /schemas/<schema_title>`
**Example:**
```
curl http://localhost:5050/schemas/User
```

### Create a schema
**Endpoint:** `POST /schemas`

Create and save a schema

**Example:**
```bash
curl -X POST "http://localhost:5050/Schemas" \
     -H "Content-Type: application/json" \
     -d '{
       "User": {
         "Name": {"type": "name"},
         "Age": {"type": "gauss_int", "parameters": {"mu": 30, "sigma": 10}},
         "Email" :{"type":"email"}
       }
     }'
``` 
**Success response (201)**:
```
The following schema has been defined: User
```

### Generate Data
**Endpoint:** `GET /schemas/<schema_title>/data`
**Example:**
```
curl -X GET "http://localhost:5050/Schemas/User/data?no=100" \
     -H "Accept: application/json"
```
Endpoint can output to json, ndjson or csv files.

### Deleting a schema
**Endpoint:** `DELETE /Schemas/<schema_title>`

## Schema Structure

A schema defines the structure and data types for your synthetic documents. Schemas are JSON objects where each key represents a field name, and each value specifies how that field should be generated.

### Basic Schema Format
```
{
  "FieldName": {
    "type": "datatype_name",           // Required: the data type to generate
    "parameters": {...},                // Optional: parameters for the data type
    "dependencies": {...}               // Optional: how this field depends on others
  }
}
```
**Simple Schema Example**

The most basic schema contains only independent fields with no dependencies:

```
{
  "Name": {"type": "name"},
  "Email": {"type": "email"},
  "Age": {"type": "gauss_int",
    "parameters": {
      "mu": 30,
      "sigma": 10
    }
  }
}
```
Will produce data that looks like this:
```
{
  "Name": "Sarah Williams",
  "Email": "adam29@yahoo.com",
  "Age": 34
}
```
### Schema components 
**1. type (Required)**
Specifies the data type to generate. Must be one of the supported data types (see Field Types section).

**2. parameters (Optional)**
Provides configuration for the data type generator. Different data types accept different parameters.
```
"Height": {
  "type": "gauss_int",
  "parameters": {
    "mu": 175,        // mean height in cm
    "sigma": 10       // standard deviation
  }
}
```
**3. dependencies** (optional)
Defines how this field depends on other fields in the schema. See the Dependencies section for detailed information.
```
"Email": {
  "type": "email",
  "dependencies": {
    "reference": "Name",
    "parameters": {
      "name": "Name",
      "t": "email"
    }
  }
}
```

### Field Types

  - name → random full name

  - uuid → random UUID (v4)

  - email → random email (or based on dependency if specified)

  - ipv4, ipv6 → random IP addresses

  - phone number → random phone number

  - address → random address

  - username → random username

  - password → random password

  - boolean → true/false value

  - domain → random domain name

  - country code → 2-letter ISO country code

  - timestamp → random ISO 8601 timestamp

  - HTTP status → random HTTP error/status message

  - user agent → random HTTP user agent string

  - HTTP method → random HTTP method (GET, POST, etc.)

  - hostname → random hostname

  - HTTP code → numeric HTTP status code

### Numerical field types
These generate numbers using distributions or formulas:

  - random int → uniform random integer between given bounds (low, high).

  - randfloat → uniform random float between bounds.

  - random normal → normally distributed float (mu, sigma).

  - gauss int → normally distributed integer, clamped at zero.

  - clamped gauss → Gaussian int with an upper bound (mu, sigma, max).

  - linear → computes m*x + c.

  - quadratic → computes m*x^2 + c.

  - skew normal (rand_skew) → skewed normal distribution.

### Categorical / Domain-Specific Field Types
Predefined categories with weighted probabilities:

  - sex → "male" or "female" with customizable probabilities.

  - stance → "Southpaw", "Conventional", "Switch" with weights.

  - Org → MMA promotion (UFC, ONE FC, Bellator, etc.) with weights.

  - style → "boxer", "wrestler", "muay thai", etc. with weights.

  - weightclass → "Flyweight", "Lightweight", "Heavyweight", etc. with weights.

  - Sizes → "Flyweight", "Lightweight", "Heavyweight".

  - style small → "boxer" or "wrestler".

## Dependencies

Dependencies allow fields to reference or react to values from other fields, creating realistic relationships in your synthetic data.
There are three types of dependencies: **Reference**, **Conditional (Single Field)**, and **Conditional (Multiple Fields)**.

---

## Dependency Types Overview

| Type | Use Case | Example |
|------|----------|---------|
| **Reference** | Use another field's value as a parameter | Email based on Name |
| **Conditional (Single)** | Change parameters based on one field | Salary based on Department |
| **Conditional (Multiple)** | Change parameters based on multiple fields | Weight based on WeightClass AND Sex |

---

## 1. Reference Dependencies

Reference dependencies allow you to use the value from another field as a parameter in the current field's generation.

### When to Use
- Creating consistent derived data (username from name, email from name)
- Building related identifiers
- Ensuring data relationships

### Structure
```json{
  "FieldName": {
    "type": "datatype",
    "dependencies": {
      "reference": "SourceField",      // Field to pull value from
      "parameters": {
        "param1": "SourceField",       // Gets replaced with actual value
        "param2": "static_value"       // Stays as-is
      }
    }
  }
}
```
The reference field is generated first
In parameters, any value that exactly matches the reference field name gets replaced with that field's actual generated value.
Other parameter values remain static
**Example**
```
{
  "Name": {"type": "name"},
  "Email": {"type": "email",
    "dependencies": {"reference": "Name",
      "parameters": {
        "name": "Name",        // This gets replaced with Name's value
        "t": "email"           // This stays as "email"
      }
    }
  }
}

```
Output 
```
{
  "Name": "Jennifer Martinez",
  "Username": "jennifermartinez7"}
```
**Field Order Matters 
The referenced field must be defined before the dependent field**

## 2. Conditional Dependencies (Single Field)
Conditional dependencies change the parameters used for generation based on the value of another field.

Use when:

- Parameters depend on a category (salary based on department)
- Different distributions for different groups (height based on gender)
- Context-specific value ranges
```
{
  "DependentField": {
    "type": "datatype",
    "dependencies": {
      "conditional": "SourceField",      // String for single field
      "CategoryValue1": {...params...},  // Parameters if SourceField = CategoryValue1
      "CategoryValue2": {...params...},  // Parameters if SourceField = CategoryValue2
      "CategoryValue3": {...params...}   // Parameters if SourceField = CategoryValue3
    }
  }
}
```
**Example**
**Average height based on gender**
```
{
        "Sex":{"type": "sex","parameters":{"m":1,"f":1}},
        "Height":{"type": "gauss int",
                  "dependencies": {"conditional":"Sex",
                                   "male":{"mu": 178, "sigma": 15}, #Parameters that get passed into the gauss int function for male
                                   "female":{"mu": 161, "sigma": 15}}, #paraameters that are passed for female

         }}
```
**⚠️ All Categories Must Be Defined
You must provide parameters for every possible value the source field can generate**

### 3. Conditional Dependencies (Multiple Fields)
Conditional dependencies can be nested to depend on multiple fields simultaneously.
When to Use:

- Parameters depend on multiple categories (weight based on weight class AND sex)
- Complex multi-dimensional relationships
```
{
  "DependentField": {
    "type": "datatype",
    "dependencies": {
      "conditional": ["Field1", "Field2"],    // List for multiple fields
      "Field1Value1": {
        "Field2Value1": {...params...},
        "Field2Value2": {...params...}
      },
      "Field1Value2": {
        "Field2Value1": {...params...},
        "Field2Value2": {...params...}
      }
    }
  }
}
```
### How It Works

- Generate both source fields
- Navigate the nested structure: First by Field1's value, then by Field2's value
- Use the resulting parameters

The order in the conditional list determines navigation order:
```
"conditional": ["Field1", "Field2"]
// Navigate: dependencies[Field1_value][Field2_value]

"conditional": ["Field2", "Field1"]
// Navigate: dependencies[Field2_value][Field1_value]
```
**⚠️ Complete Coverage Required
You must provide parameters for every combination of source field values**
